// Generated by kea-typegen on Mon, 25 Mar 2024 14:11:49 GMT. DO NOT EDIT THIS FILE MANUALLY.

import type { Logic } from 'kea'

import type { FluidLogicFormFields } from './fluidLogic'
import type { DeepPartial, DeepPartialMap, FieldName, ValidationErrorType } from 'kea-forms'
import type { ChartType, GranularityType } from 'grommet/components/DataChart/index'

export interface fluidLogicType extends Logic {
  actionCreators: {
    setFluidLogicFormValue: (
      key: FieldName,
      value: any
    ) => {
      type: "set fluid logic form value (src.logics.fluidLogic)";
      payload: {
        name: FieldName;
        value: any;
      };
    };
    setFluidLogicFormValues: (values: DeepPartial<FluidLogicFormFields>) => {
      type: "set fluid logic form values (src.logics.fluidLogic)";
      payload: {
        values: DeepPartial<FluidLogicFormFields>;
      };
    };
    setFluidLogicFormManualErrors: (errors: Record<string, any>) => {
      type: "set fluid logic form manual errors (src.logics.fluidLogic)";
      payload: {
        errors: Record<string, any>;
      };
    };
    touchFluidLogicFormField: (key: string) => {
      type: "touch fluid logic form field (src.logics.fluidLogic)";
      payload: {
        key: string;
      };
    };
    resetFluidLogicForm: (values?: FluidLogicFormFields) => {
      type: "reset fluid logic form (src.logics.fluidLogic)";
      payload: {
        values?: FluidLogicFormFields;
      };
    };
    submitFluidLogicForm: () => {
      type: "submit fluid logic form (src.logics.fluidLogic)";
      payload: {
        value: boolean;
      };
    };
    submitFluidLogicFormRequest: (fluidLogicForm: FluidLogicFormFields) => {
      type: "submit fluid logic form request (src.logics.fluidLogic)";
      payload: {
        fluidLogicForm: FluidLogicFormFields;
      };
    };
    submitFluidLogicFormSuccess: (fluidLogicForm: FluidLogicFormFields) => {
      type: "submit fluid logic form success (src.logics.fluidLogic)";
      payload: {
        fluidLogicForm: FluidLogicFormFields;
      };
    };
    submitFluidLogicFormFailure: (
      error: Error,
      errors: Record<string, any>
    ) => {
      type: "submit fluid logic form failure (src.logics.fluidLogic)";
      payload: {
        error: Error;
        errors: Record<string, any>;
      };
    };
  };
  actionKeys: {
    "set fluid logic form value (src.logics.fluidLogic)": "setFluidLogicFormValue";
    "set fluid logic form values (src.logics.fluidLogic)": "setFluidLogicFormValues";
    "set fluid logic form manual errors (src.logics.fluidLogic)": "setFluidLogicFormManualErrors";
    "touch fluid logic form field (src.logics.fluidLogic)": "touchFluidLogicFormField";
    "reset fluid logic form (src.logics.fluidLogic)": "resetFluidLogicForm";
    "submit fluid logic form (src.logics.fluidLogic)": "submitFluidLogicForm";
    "submit fluid logic form request (src.logics.fluidLogic)": "submitFluidLogicFormRequest";
    "submit fluid logic form success (src.logics.fluidLogic)": "submitFluidLogicFormSuccess";
    "submit fluid logic form failure (src.logics.fluidLogic)": "submitFluidLogicFormFailure";
  };
  actionTypes: {
    setFluidLogicFormValue: "set fluid logic form value (src.logics.fluidLogic)";
    setFluidLogicFormValues: "set fluid logic form values (src.logics.fluidLogic)";
    setFluidLogicFormManualErrors: "set fluid logic form manual errors (src.logics.fluidLogic)";
    touchFluidLogicFormField: "touch fluid logic form field (src.logics.fluidLogic)";
    resetFluidLogicForm: "reset fluid logic form (src.logics.fluidLogic)";
    submitFluidLogicForm: "submit fluid logic form (src.logics.fluidLogic)";
    submitFluidLogicFormRequest: "submit fluid logic form request (src.logics.fluidLogic)";
    submitFluidLogicFormSuccess: "submit fluid logic form success (src.logics.fluidLogic)";
    submitFluidLogicFormFailure: "submit fluid logic form failure (src.logics.fluidLogic)";
  };
  actions: {
    setFluidLogicFormValue: (key: FieldName, value: any) => void;
    setFluidLogicFormValues: (
      values: DeepPartial<FluidLogicFormFields>
    ) => void;
    setFluidLogicFormManualErrors: (errors: Record<string, any>) => void;
    touchFluidLogicFormField: (key: string) => void;
    resetFluidLogicForm: (values?: FluidLogicFormFields) => void;
    submitFluidLogicForm: () => void;
    submitFluidLogicFormRequest: (fluidLogicForm: FluidLogicFormFields) => void;
    submitFluidLogicFormSuccess: (fluidLogicForm: FluidLogicFormFields) => void;
    submitFluidLogicFormFailure: (
      error: Error,
      errors: Record<string, any>
    ) => void;
  };
  asyncActions: {
    setFluidLogicFormValue: (key: FieldName, value: any) => Promise<any>;
    setFluidLogicFormValues: (
      values: DeepPartial<FluidLogicFormFields>
    ) => Promise<any>;
    setFluidLogicFormManualErrors: (
      errors: Record<string, any>
    ) => Promise<any>;
    touchFluidLogicFormField: (key: string) => Promise<any>;
    resetFluidLogicForm: (values?: FluidLogicFormFields) => Promise<any>;
    submitFluidLogicForm: () => Promise<any>;
    submitFluidLogicFormRequest: (
      fluidLogicForm: FluidLogicFormFields
    ) => Promise<any>;
    submitFluidLogicFormSuccess: (
      fluidLogicForm: FluidLogicFormFields
    ) => Promise<any>;
    submitFluidLogicFormFailure: (
      error: Error,
      errors: Record<string, any>
    ) => Promise<any>;
  };
  defaults: {
    fluidLogicForm: FluidLogicFormFields;
    isFluidLogicFormSubmitting: boolean;
    showFluidLogicFormErrors: boolean;
    fluidLogicFormChanged: boolean;
    fluidLogicFormTouches: Record<string, boolean>;
    fluidLogicFormManualErrors: Record<string, any>;
  };
  events: {};
  key: undefined;
  listeners: {};
  path: ["src", "logics", "fluidLogic"];
  pathString: "src.logics.fluidLogic";
  props: Record<string, unknown>;
  reducer: (
    state: any,
    action: any,
    fullState: any
  ) => {
    fluidLogicForm: FluidLogicFormFields;
    isFluidLogicFormSubmitting: boolean;
    showFluidLogicFormErrors: boolean;
    fluidLogicFormChanged: boolean;
    fluidLogicFormTouches: Record<string, boolean>;
    fluidLogicFormManualErrors: Record<string, any>;
  };
  reducers: {
    fluidLogicForm: (
      state: FluidLogicFormFields,
      action: any,
      fullState: any
    ) => FluidLogicFormFields;
    isFluidLogicFormSubmitting: (
      state: boolean,
      action: any,
      fullState: any
    ) => boolean;
    showFluidLogicFormErrors: (
      state: boolean,
      action: any,
      fullState: any
    ) => boolean;
    fluidLogicFormChanged: (
      state: boolean,
      action: any,
      fullState: any
    ) => boolean;
    fluidLogicFormTouches: (
      state: Record<string, boolean>,
      action: any,
      fullState: any
    ) => Record<string, boolean>;
    fluidLogicFormManualErrors: (
      state: Record<string, any>,
      action: any,
      fullState: any
    ) => Record<string, any>;
  };
  selector: (state: any) => {
    fluidLogicForm: FluidLogicFormFields;
    isFluidLogicFormSubmitting: boolean;
    showFluidLogicFormErrors: boolean;
    fluidLogicFormChanged: boolean;
    fluidLogicFormTouches: Record<string, boolean>;
    fluidLogicFormManualErrors: Record<string, any>;
  };
  selectors: {
    fluidLogicForm: (state: any, props?: any) => FluidLogicFormFields;
    isFluidLogicFormSubmitting: (state: any, props?: any) => boolean;
    showFluidLogicFormErrors: (state: any, props?: any) => boolean;
    fluidLogicFormChanged: (state: any, props?: any) => boolean;
    fluidLogicFormTouches: (state: any, props?: any) => Record<string, boolean>;
    fluidLogicFormManualErrors: (
      state: any,
      props?: any
    ) => Record<string, any>;
    fluidLogicFormTouched: (state: any, props?: any) => boolean;
    fluidLogicFormValidationErrors: (
      state: any,
      props?: any
    ) => DeepPartialMap<FluidLogicFormFields, ValidationErrorType>;
    fluidLogicFormAllErrors: (state: any, props?: any) => Record<string, any>;
    fluidLogicFormHasErrors: (state: any, props?: any) => boolean;
    fluidLogicFormErrors: (
      state: any,
      props?: any
    ) => DeepPartialMap<FluidLogicFormFields, ValidationErrorType>;
    isFluidLogicFormValid: (state: any, props?: any) => boolean;
    sizeMin: (state: any, props?: any) => number;
    sizeMax: (state: any, props?: any) => number;
    rootFontSize: (state: any, props?: any) => number;
    sizeUnits: (state: any, props?: any) => "cqw" | "px" | "rem" | "vw";
    containerMin: (state: any, props?: any) => number;
    containerMax: (state: any, props?: any) => number;
    containerTarget: (state: any, props?: any) => "container" | "viewport";
    min: (state: any, props?: any) => string;
    max: (state: any, props?: any) => string;
    containerCoefficientValue: (state: any, props?: any) => number;
    containerCoefficient: (state: any, props?: any) => string;
    mixinCoefficientValue: (state: any, props?: any) => number;
    mixinCoefficient: (state: any, props?: any) => string;
    clampFormula: (state: any, props?: any) => string;
    chartBounds: (
      state: any,
      props?: any
    ) => {
      x: number[];
      y: number[];
    };
    chartData: (
      state: any,
      props?: any
    ) => {
      current: boolean;
      screenSize: number;
      target: number;
    }[];
    chartSeries: (
      state: any,
      props?: any
    ) => (
      | string
      | {
          property: string;
          suffix: string;
        }
    )[];
    chartAxes: (
      state: any,
      props?: any
    ) =>
      | boolean
      | {
          x?:
            | boolean
            | string
            | {
                granularity?: GranularityType | undefined;
                property?: string | undefined;
              }
            | undefined;
          y?:
            | boolean
            | string
            | {
                granularity?: GranularityType | undefined;
                property?: string | undefined;
              }
            | undefined;
        }
      | undefined;
    chartType: (state: any, props?: any) => ChartType | ChartType[] | undefined;
    chartGuide: (
      state: any,
      props?: any
    ) =>
      | boolean
      | {
          x?:
            | boolean
            | {
                granularity?: GranularityType | undefined;
              }
            | undefined;
          y?:
            | boolean
            | {
                granularity?: GranularityType | undefined;
              }
            | undefined;
        }
      | undefined;
  };
  sharedListeners: {};
  values: {
    fluidLogicForm: FluidLogicFormFields;
    isFluidLogicFormSubmitting: boolean;
    showFluidLogicFormErrors: boolean;
    fluidLogicFormChanged: boolean;
    fluidLogicFormTouches: Record<string, boolean>;
    fluidLogicFormManualErrors: Record<string, any>;
    fluidLogicFormTouched: boolean;
    fluidLogicFormValidationErrors: DeepPartialMap<
      FluidLogicFormFields,
      ValidationErrorType
    >;
    fluidLogicFormAllErrors: Record<string, any>;
    fluidLogicFormHasErrors: boolean;
    fluidLogicFormErrors: DeepPartialMap<
      FluidLogicFormFields,
      ValidationErrorType
    >;
    isFluidLogicFormValid: boolean;
    sizeMin: number;
    sizeMax: number;
    rootFontSize: number;
    sizeUnits: "cqw" | "px" | "rem" | "vw";
    containerMin: number;
    containerMax: number;
    containerTarget: "container" | "viewport";
    min: string;
    max: string;
    containerCoefficientValue: number;
    containerCoefficient: string;
    mixinCoefficientValue: number;
    mixinCoefficient: string;
    clampFormula: string;
    chartBounds: {
      x: number[];
      y: number[];
    };
    chartData: {
      current: boolean;
      screenSize: number;
      target: number;
    }[];
    chartSeries: (
      | string
      | {
          property: string;
          suffix: string;
        }
    )[];
    chartAxes:
      | boolean
      | {
          x?:
            | boolean
            | string
            | {
                granularity?: GranularityType | undefined;
                property?: string | undefined;
              }
            | undefined;
          y?:
            | boolean
            | string
            | {
                granularity?: GranularityType | undefined;
                property?: string | undefined;
              }
            | undefined;
        }
      | undefined;
    chartType: ChartType | ChartType[] | undefined;
    chartGuide:
      | boolean
      | {
          x?:
            | boolean
            | {
                granularity?: GranularityType | undefined;
              }
            | undefined;
          y?:
            | boolean
            | {
                granularity?: GranularityType | undefined;
              }
            | undefined;
        }
      | undefined;
  };
  _isKea: true;
  _isKeaWithKey: false;
  __keaTypeGenInternalSelectorTypes: {
    sizeMin: (fluidLogicForm: FluidLogicFormFields) => number;
    sizeMax: (fluidLogicForm: FluidLogicFormFields) => number;
    rootFontSize: (fluidLogicForm: FluidLogicFormFields) => number;
    sizeUnits: (
      fluidLogicForm: FluidLogicFormFields
    ) => "cqw" | "px" | "rem" | "vw";
    containerMin: (fluidLogicForm: FluidLogicFormFields) => number;
    containerMax: (fluidLogicForm: FluidLogicFormFields) => number;
    containerTarget: (
      fluidLogicForm: FluidLogicFormFields
    ) => "container" | "viewport";
    min: (sizeMin: number, sizeUnits: "cqw" | "px" | "rem" | "vw") => string;
    max: (fluidLogicForm: FluidLogicFormFields) => string;
    containerCoefficientValue: (
      sizeMin: number,
      sizeMax: number,
      containerMin: number,
      containerMax: number,
      rootFontSize: number,
      sizeUnits: "cqw" | "px" | "rem" | "vw"
    ) => number;
    containerCoefficient: (
      containerCoefficientValue: number,
      containerTarget: "container" | "viewport"
    ) => string;
    mixinCoefficientValue: (
      sizeMin: number,
      sizeMax: number,
      containerMin: number,
      containerMax: number,
      rootFontSize: number,
      sizeUnits: "cqw" | "px" | "rem" | "vw"
    ) => number;
    mixinCoefficient: (mixinCoefficientValue: number) => string;
    clampFormula: (
      min: string,
      containerCoefficient: string,
      mixinCoefficient: string,
      max: string
    ) => string;
    chartBounds: (
      containerMin: number,
      containerMax: number,
      sizeMin: number,
      sizeMax: number
    ) => {
      x: number[];
      y: number[];
    };
    chartData: (
      containerMin: number,
      containerMax: number,
      sizeMin: number,
      sizeMax: number
    ) => {
      current: boolean;
      screenSize: number;
      target: number;
    }[];
    chartSeries: (sizeUnits: "cqw" | "px" | "rem" | "vw") => (
      | string
      | {
          property: string;
          suffix: string;
        }
    )[];
  };
}
